from __future__ import annotations

from collections.abc import Sequence
from dataclasses import dataclass
from os import PathLike
from typing import Any

import sqlalchemy
from alembic import command, context
from alembic.config import Config
from sqlalchemy import MetaData


@dataclass
class AlembicUpgrade:
    """Provides a way to perform an Alembic upgrade to revision `head` from
    Python code, without having to run the `alembic` CLI tool in a shell."""

    script_location: str | PathLike[Any]
    """The path to the alembic migrations directory (the directory containing
    the env.py file.)"""

    def execute(self) -> None:
        alembic_cfg = Config(config_args={"script_location": str(self.script_location)})
        command.upgrade(alembic_cfg, "head")


@dataclass
class AlembicEnv:
    """Provides an online-only migrations runner, that can be used to perform the work
    that is required in alembic's `env.py` file.

    An `alembic.ini` file only has to point the `script_location` at the migrations
    directory to use. This class will take care of configuring alembic and setting
    up a connection to the database using the provided SqlAlchemy Engine."""

    engine: sqlalchemy.Engine
    """A configured SqlAlchemy Engine that can be used to set up the database connection."""

    target_metadata: sqlalchemy.MetaData | Sequence[sqlalchemy.MetaData] | None = None
    """Optional SqlAlchemy ORM MetaData, when the schema is to be based on such MetaData.
    When using metadata for the schema definition, this class will make sure that only
    the tables as defined in the metadata are managed by Alembic. Otherwise, when generating
    schema updates, Alembic would drop all other tables that might be in the database (e.g.
    when storing multiple Alembic schemas in a single database.) This does mean that when
    you actually want to drop a table, you will have to add a schema migration for that
    manually. This being a very rare event, this seems a good trade-off."""

    version_table: str | None = None
    """Can be used to override the default `alembic_version` table name. This can be
    useful in case multiple schemas have to be stored in the same database. Each schema
    needs its own versioning table."""

    def execute(self) -> None:
        self._ensure_online_mode()
        self._prepare_context()
        self._run_migrations()

    @staticmethod
    def _ensure_online_mode() -> None:
        if context.is_offline_mode():
            raise RuntimeError("Offline mode is not supported")

    @staticmethod
    def _prepare_context() -> None:
        context.config.set_main_option("prepend_sys_path", ".")
        context.config.set_main_option("version_path_separator", "os")

    def _run_migrations(self) -> None:
        with self.engine.connect() as connection:
            context.configure(
                connection=connection,
                target_metadata=self.target_metadata,
                include_object=self._make_include_object_function(),
                version_table=self.version_table or "alembic_version",
            )
            with context.begin_transaction():
                context.run_migrations()

    def _make_include_object_function(self) -> Any:
        if self.target_metadata is None:
            return None

        def include_object(
            object_: Any,  # noqa (not used, but part of interface)
            name: str,
            type_: str,
            reflected: bool,  # noqa (not used, but part of interface)
            compare_to: Any,  # noqa (not used, but part of interface)
        ) -> bool:
            """Makes sure that auto-generating schema updates will not take other
            tables in the database into account. For those, autogenerated updates
            would otherwise include dropping those tables, to bring the database
            fully in line with the ORM metadata."""
            assert self.target_metadata is not None
            if type_ != "table":
                return True
            if isinstance(self.target_metadata, MetaData):
                if name not in self.target_metadata.tables:
                    return False
            else:
                if all(name not in metadata for metadata in self.target_metadata):
                    return False
            return True

        return include_object
